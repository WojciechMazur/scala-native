#include <stdatomic.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>


% for order in ['relaxed', 'consume', 'acquire', 'release', 'acq_rel', 'seq_cst']: 
  memory_order scalanative_atomic_memory_order_${order}(){
    return memory_order_${order};
  }
% end

%{
  atomics = [('int8_t','byte'),
            ('int16_t','short'),
            ('int32_t','int'),
            ('int64_t','long'),
            ('uint8_t','ubyte'),
            ('uint16_t','ushort'),
            ('uint32_t','uint'),
            ('uint64_t','ulong'),
            ('char','char'),
            ('unsigned char','uchar'),
            ('intptr_t', 'intptr'),
            ('size_t','csize')]

}%

% for (T, N) in atomics:
  void scalanative_atomic_init_${N}(${T}* atm, ${T} init_value) {
    *atm = ATOMIC_VAR_INIT(init_value);
  }

  ${T} scalanative_atomic_load_${N}(_Atomic(${T})* atm) {
      return atomic_load(atm);
  }

  ${T} scalanative_atomic_load_explicit_${N}(_Atomic(${T})* atm, memory_order memoryOrder) {
      return atomic_load_explicit(atm, memoryOrder);
  }

  void scalanative_atomic_store_${N}(_Atomic(${T})* atm, ${T} val) {
    atomic_store(atm, val);
  }

    void scalanative_atomic_store_explicit_${N}(_Atomic(${T})* atm, ${T} val, memory_order memoryOrder) {
    atomic_store_explicit(atm, val, memoryOrder);
  }

  ${T} scalanative_atomic_exchange_${N}(_Atomic(${T})* atm, ${T} val) {
    return atomic_exchange(atm, val);
  }

    ${T} scalanative_atomic_exchange_explicit_${N}(_Atomic(${T})* atm, ${T} val, memory_order memoryOrder) {
    return atomic_exchange_explicit(atm, val, memoryOrder);
  }


% for cmp in ['strong', 'weak']:
    bool scalanative_atomic_compare_exchange_${cmp}_${N}(_Atomic(${T})* atm, ${T}* expected, ${T} desired) {
        return atomic_compare_exchange_${cmp}(atm, expected, desired);
    }

    bool scalanative_atomic_compare_exchange_${cmp}_explicit_${N}(_Atomic(${T})* atm, ${T}* expected, ${T} desired, memory_order onSucc, memory_order onFail) {
      return atomic_compare_exchange_${cmp}_explicit(atm, expected, desired, onSucc, onFail);
    }
% end

% for op in ['add', 'sub', 'and', 'or', 'xor']:
  ${T} scalanative_atomic_fetch_${op}_${N}(_Atomic(${T})* atm, ${T} val) {
    return atomic_fetch_${op}(atm, val);
  }
  ${T} scalanative_atomic_fetch_${op}_explicit_${N}(_Atomic(${T})* atm, ${T} val, memory_order memoryOrder) {
      return atomic_fetch_${op}_explicit(atm, val, memoryOrder);
    }
% end
% end


void scalanative_atomic_flag_init(atomic_flag* atm, bool init_value) {
  atomic_flag zero = ATOMIC_FLAG_INIT;
  *atm = zero;
}

bool scalanative_atomic_flag_test_and_set(atomic_flag* obj) {
  return atomic_flag_test_and_set(obj);
}

bool scalanative_atomic_flag_test_and_set_explicit(atomic_flag* obj, memory_order order) {
  return atomic_flag_test_and_set_explicit(obj, order);
}

void scalanative_atomic_flag_test_and_clear(atomic_flag* obj) {
  return atomic_flag_clear(obj);
}

void scalanative_atomic_flag_test_and_clear_explicit(atomic_flag* obj, memory_order order) {
  return atomic_flag_clear_explicit(obj, order);
}