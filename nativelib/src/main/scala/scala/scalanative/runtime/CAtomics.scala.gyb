package scala.scalanative.runtime

import scala.scalanative.unsafe._
import scala.scalanative.unsigned._
import scala.scalanative.runtime.Atomic._
import scala.language.implicitConversions

sealed trait CAtomic[T]{
  def load(): T
  def store(value: T): Unit
  def free(): Unit
  def compareAndSwapStrong(expected: T, desired: T): (Boolean, T)
  def compareAndSwapWeak(expected: T, desired: T): (Boolean, T)
  def addFetch(value: T): T
  def fetchAdd(value: T): T
  def subFetch(value: T): T
  def fetchSub(value: T): T
  def andFetch(value: T): T
  def fetchAnd(value: T): T
  def orFetch(value: T): T
  def fetchOr(value: T): T
  def xorFetch(value: T): T
  def fetchXor(value: T): T
}

%{
	classes = ['Byte', 'Short', 'Int', 'Long',
					 'UByte', 'UShort', 'UInt', 'ULong',
					 'Char', 'CSize']

	types = ['Byte', 'CShort', 'CInt', 'CLong',
					'UByte', 'UShort', 'UInt', 'ULong',
					'CChar', 'CSize']

	names = ['byte', 'short', 'int', 'long',
					'ubyte', 'ushort', 'uint', 'ulong',
					'char', 'csize']

	defaults = ['0.toByte', '0.toShort', '0', '0L',
						 '0.toUByte', '0.toUShort', '0.toUInt', '0.toULong',
						 '0.toByte', '0.toUInt']
}%
% for (C, T, N, default) in zip(classes, types, names, defaults):

final case class CAtomic${C}(private val initValue: ${T} = ${default}) extends CAtomic[${T}] {
  private[this] val underlying: Ptr[${T}] = fromRawPtr(libc.malloc(sizeof[${T}]))
  atomic_init_${N}(underlying, initValue)

  def free(): Unit = libc.free(toRawPtr(underlying))

  def load(): ${T} = atomic_load_${N}(underlying)

  def store(value: ${T}): Unit = atomic_store_${N}(underlying, value)

  def exchange(value: ${T}): ${T} = atomic_exchange_${N}(underlying, value)

  def compareAndSwapStrong(expected: ${T}, desired: ${T}): (Boolean, ${T}) = {
    val expectedPtr: Ptr[${T}] = fromRawPtr(Intrinsics.stackalloc(sizeof[${T}]))
    !expectedPtr = expected    
    if (compare_and_swap_strong_${N}(underlying, expectedPtr, desired)) {
      (true, desired)
    } else {
      (false, !expectedPtr)
    }
  }

  def compareAndSwapWeak(expected: ${T}, desired: ${T}): (Boolean, ${T}) = {
    val expectedPtr: Ptr[${T}] = fromRawPtr(Intrinsics.stackalloc(sizeof[${T}]))
    !expectedPtr = expected    
    if (compare_and_swap_weak_${N}(underlying, expectedPtr, desired)) {
      (true, desired)
    } else {
      (false, !expectedPtr)
    }
  }

  def addFetch(value: ${T}): ${T} = {
    fetchAdd(value)
    load()
  }

  def fetchAdd(value: ${T}): ${T} = atomic_add_${N}(underlying, value)

  def subFetch(value: ${T}): ${T} = {
    fetchSub(value)
    load()
  }

  def fetchSub(value: ${T}): ${T} = atomic_sub_${N}(underlying, value)

  def andFetch(value: ${T}): ${T} = {
    fetchAnd(value)
    load()
  }

  def fetchAnd(value: ${T}): ${T} = atomic_and_${N}(underlying, value)

  def orFetch(value: ${T}): ${T} = {
    fetchOr(value)
    load()
  }

  def fetchOr(value: ${T}): ${T} = atomic_or_${N}(underlying, value)

  def xorFetch(value: ${T}): ${T} = {
    fetchXor(value)
    load()
  }

  def fetchXor(value: ${T}): ${T} = atomic_xor_${N}(underlying, value)

  override def toString(): String = load().toString

  override def equals(that: Any): Boolean = that match {
    case o: CAtomic${C} => o.load() == load()
    case o: ${T} => load() == o
    case _ => false
  }

}
% end

final case class CAtomicRef[T <: AnyRef](default: T = null.asInstanceOf[T]) extends CAtomic[T] {
  type Repr = CLong
  private[this] val underlying: Ptr[Repr] = fromRawPtr(libc.malloc(sizeof[Repr]))
  atomic_init_long(underlying, default)

  def free(): Unit = libc.free(toRawPtr(underlying))

  def load(): T = atomic_load_long(underlying)

  def store(value: T): Unit = atomic_store_long(underlying, value)

  def exchange(value: T): T = atomic_exchange_long(underlying, value)

  def compareAndSwapStrong(expected: T, desired: T): (Boolean, T) = {
    val expectedPtr: Ptr[Repr] = fromRawPtr(Intrinsics.stackalloc(sizeof[Repr]))
    !expectedPtr = expected    
    if (compare_and_swap_strong_long(underlying, expectedPtr, desired)) {
      (true, desired)
    } else {
      (false, !expectedPtr)
    }
  }

  def compareAndSwapWeak(expected: T, desired: T): (Boolean, T) = {
    val expectedPtr: Ptr[Repr] = fromRawPtr(Intrinsics.stackalloc(sizeof[Repr]))
    !expectedPtr = expected        
    if (compare_and_swap_weak_long(underlying, expectedPtr, desired)) {
      (true, desired)
    } else {
      (false, !expectedPtr)
    }
  }

  def addFetch(value: T): T = throw new UnsupportedOperationException()
  def fetchAdd(value: T): T = throw new UnsupportedOperationException()
  def subFetch(value: T): T = throw new UnsupportedOperationException()
  def fetchSub(value: T): T = throw new UnsupportedOperationException()
  def andFetch(value: T): T = throw new UnsupportedOperationException()
  def fetchAnd(value: T): T = throw new UnsupportedOperationException()
  def orFetch(value: T): T  = throw new UnsupportedOperationException()
  def fetchOr(value: T): T  = throw new UnsupportedOperationException()
  def xorFetch(value: T): T = throw new UnsupportedOperationException()
  def fetchXor(value: T): T = throw new UnsupportedOperationException()

  override def toString(): String = load().toString

  override def equals(that: Any): Boolean = that match {
    case o: CAtomicRef[_] @unchecked => o.load() == load()
    case o: T @unchecked             => load() == o
    case _                					 => false
  }

  private implicit def toRepr(ref: T): Repr = Intrinsics.castRawPtrToLong {
    Intrinsics.castObjectToRawPtr(ref)
  }
  private implicit def toRef(repr: Repr): T = {
    Intrinsics
      .castRawPtrToObject {
        Intrinsics.castLongToRawPtr(repr)
      }
      .asInstanceOf[T]
  }
}

// Helper object, can be imported for ease of use
object CAtomicsImplicits {
  implicit def cas[T](v: (Boolean, T)): Boolean = v._1
	implicit def underlying[T <: AnyRef](v: CAtomicRef[T]): T = v.load()
  %for (C, T) in zip(classes, types):
  implicit def underlying(a: CAtomic${C}): ${T} = a.load()
  %end
}