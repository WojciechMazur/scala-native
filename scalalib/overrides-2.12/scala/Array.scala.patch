--- scalaSources/2.12.14/scala/Array.scala
+++ overrides-2.12/scala/Array.scala
@@ -12,26 +12,23 @@
 
 package scala
 
 import scala.collection.generic._
-import scala.collection.{immutable, mutable}
-import mutable.{ArrayBuilder, ArraySeq}
-import scala.reflect.{ClassTag, classTag}
-import scala.runtime.ScalaRunTime
-import scala.runtime.ScalaRunTime.{array_apply, array_update}
+import scala.collection.{ mutable, immutable }
+import mutable.{ ArrayBuilder, ArraySeq }
+import scala.reflect.ClassTag
+import scala.runtime.ScalaRunTime.{ array_apply, array_update }
+import scala.collection.mutable.WrappedArray
 
-/** Contains a fallback builder for arrays when the element type
- *  does not have a class tag. In that case a generic array is built.
+/** Contains a fallback builder for arrays when the element type *  does not have a class tag. In that case a generic array is built.
  */
 class FallbackArrayBuilding {
 
-  /** A builder factory that generates a generic array.
-   *  Called instead of `Array.newBuilder` if the element type of an array
+  /** A builder factory that generates a generic array.   *  Called instead of `Array.newBuilder` if the element type of an array
    *  does not have a class tag. Note that fallbackBuilder factory
    *  needs an implicit parameter (otherwise it would not be dominated in
    *  implicit search by `Array.canBuildFrom`). We make sure that
-   *  implicit search is always successful.
-   */
+   *  implicit search is always successful.   */
   implicit def fallbackCanBuildFrom[T](implicit m: DummyImplicit): CanBuildFrom[Array[_], T, ArraySeq[T]] =
     new CanBuildFrom[Array[_], T, ArraySeq[T]] {
       def apply(from: Array[_]) = ArraySeq.newBuilder[T]
       def apply() = ArraySeq.newBuilder[T]
@@ -51,35 +48,31 @@
  *  @author Martin Odersky
  *  @since  1.0
  */
 object Array extends FallbackArrayBuilding {
+  @inline def emptyBooleanArray = new Array[Boolean](0)
+  @inline def emptyByteArray    = new Array[Byte](0)
+  @inline def emptyCharArray    = new Array[Char](0)
+  @inline def emptyDoubleArray  = new Array[Double](0)
+  @inline def emptyFloatArray   = new Array[Float](0)
+  @inline def emptyIntArray     = new Array[Int](0)
+  @inline def emptyLongArray    = new Array[Long](0)
+  @inline def emptyShortArray   = new Array[Short](0)
 
-  val emptyBooleanArray = empty[Boolean]
-  val emptyByteArray    = empty[Byte]
-  val emptyCharArray    = empty[Char]
-  val emptyDoubleArray  = empty[Double]
-  val emptyFloatArray   = empty[Float]
-  val emptyIntArray     = empty[Int]
-  val emptyLongArray    = empty[Long]
-  val emptyShortArray   = empty[Short]
+  @inline private[scala] //this is only private because of binary compatability
+  def emptyUnitArray    = new Array[scala.runtime.BoxedUnit](0).asInstanceOf[Array[Unit]]
+  @inline def emptyObjectArray  = new Array[Object](0)
 
-  private[scala] //this is only private because of binary compatability
-  val emptyUnitArray    = empty[scala.runtime.BoxedUnit].asInstanceOf[Array[Unit]]
-  val emptyObjectArray  = empty[Object]
-
   implicit def canBuildFrom[T](implicit tag: ClassTag[T]): CanBuildFrom[Array[_], T, Array[T]] = {
-    val cls = tag.runtimeClass
-    (if (cls.isPrimitive) {
+    val cls = tag.runtimeClass    (if (cls.isPrimitive) {
       cls match {
         case java.lang.Integer.TYPE   => cbfIntArray
         case java.lang.Double.TYPE    => cbfDoubleArray
-        case java.lang.Long.TYPE      => cbfLongArray
-        case java.lang.Float.TYPE     => cbfFloatArray
+        case java.lang.Long.TYPE      => cbfLongArray        case java.lang.Float.TYPE     => cbfFloatArray
         case java.lang.Character.TYPE => cbfCharArray
         case java.lang.Byte.TYPE      => cbfByteArray
         case java.lang.Short.TYPE     => cbfShortArray
-        case java.lang.Boolean.TYPE   => cbfBooleanArray
-        case java.lang.Void.TYPE      => cbfUnitArray
+        case java.lang.Boolean.TYPE   => cbfBooleanArray        case java.lang.Void.TYPE      => cbfUnitArray
       }
     } else if (cls == ObjectClass) {
       cbfObjectArray
     } else {
@@ -88,69 +81,65 @@
   }
   private[this] val ObjectClass = classOf[Object]
 
   private[this] val cbfBooleanArray = new CanBuildFrom[Array[_], Boolean, Array[Boolean]] {
-    def apply(from: Array[_]) = new ArrayBuilder.ofBoolean()
-    def apply() = new ArrayBuilder.ofBoolean()
+    @inline def apply(from: Array[_]) = new ArrayBuilder.ofBoolean()
+    @inline def apply() = new ArrayBuilder.ofBoolean()
   }
 
   private[this] val cbfByteArray    = new CanBuildFrom[Array[_], Byte, Array[Byte]] {
-    def apply(from: Array[_]) = new ArrayBuilder.ofByte()
-    def apply() = new ArrayBuilder.ofByte()
+    @inline def apply(from: Array[_]) = new ArrayBuilder.ofByte()
+    @inline def apply() = new ArrayBuilder.ofByte()
   }
 
   private[this] val cbfCharArray    = new CanBuildFrom[Array[_], Char, Array[Char]] {
-    def apply(from: Array[_]) = new ArrayBuilder.ofChar()
-    def apply() = new ArrayBuilder.ofChar()
+    @inline def apply(from: Array[_]) = new ArrayBuilder.ofChar()
+    @inline def apply() = new ArrayBuilder.ofChar()
   }
 
   private[this] val cbfDoubleArray  = new CanBuildFrom[Array[_], Double, Array[Double]] {
-    def apply(from: Array[_]) = new ArrayBuilder.ofDouble()
-    def apply() = new ArrayBuilder.ofDouble()
+    @inline def apply(from: Array[_]) = new ArrayBuilder.ofDouble()
+    @inline def apply() = new ArrayBuilder.ofDouble()
   }
 
   private[this] val cbfFloatArray   = new CanBuildFrom[Array[_], Float, Array[Float]] {
-    def apply(from: Array[_]) = new ArrayBuilder.ofFloat()
-    def apply() = new ArrayBuilder.ofFloat()
+    @inline def apply(from: Array[_]) = new ArrayBuilder.ofFloat()
+    @inline def apply() = new ArrayBuilder.ofFloat()
   }
 
   private[this] val cbfIntArray     = new CanBuildFrom[Array[_], Int, Array[Int]] {
-    def apply(from: Array[_]) = new ArrayBuilder.ofInt()
-    def apply() = new ArrayBuilder.ofInt()
+    @inline def apply(from: Array[_]) = new ArrayBuilder.ofInt()
+    @inline def apply() = new ArrayBuilder.ofInt()
   }
 
   private[this] val cbfLongArray    = new CanBuildFrom[Array[_], Long, Array[Long]] {
-    def apply(from: Array[_]) = new ArrayBuilder.ofLong()
-    def apply() = new ArrayBuilder.ofLong()
+    @inline def apply(from: Array[_]) = new ArrayBuilder.ofLong()
+    @inline def apply() = new ArrayBuilder.ofLong()
   }
 
   private[this] val cbfShortArray   = new CanBuildFrom[Array[_], Short, Array[Short]] {
-    def apply(from: Array[_]) = new ArrayBuilder.ofShort()
-    def apply() = new ArrayBuilder.ofShort()
+    @inline def apply(from: Array[_]) = new ArrayBuilder.ofShort()
+    @inline def apply() = new ArrayBuilder.ofShort()
   }
 
   private[this] val cbfUnitArray    = new CanBuildFrom[Array[_], Unit, Array[Unit]] {
-    def apply(from: Array[_]) = new ArrayBuilder.ofUnit()
-    def apply() = new ArrayBuilder.ofUnit()
+    @inline def apply(from: Array[_]) = new ArrayBuilder.ofUnit()
+    @inline def apply() = new ArrayBuilder.ofUnit()
   }
-
   private[this] val cbfObjectArray  = refCBF[Object]
   private[this] def refCBF[T <: AnyRef](implicit t: ClassTag[T]): CanBuildFrom[Array[_], T, Array[T]] =
     new CanBuildFrom[Array[_], T, Array[T]] {
-      def apply(from: Array[_]) = new ArrayBuilder.ofRef[T]()(t)
-      def apply() = new ArrayBuilder.ofRef[T]()(t)
+      @inline def apply(from: Array[_]) = new ArrayBuilder.ofRef[T]()(t)
+      @inline def apply() = new ArrayBuilder.ofRef[T]()(t)
     }
-
   /**
    * Returns a new [[scala.collection.mutable.ArrayBuilder]].
    */
   def newBuilder[T](implicit t: ClassTag[T]): ArrayBuilder[T] = ArrayBuilder.make[T]()(t)
-
   private def slowcopy(src : AnyRef,
                        srcPos : Int,
                        dest : AnyRef,
-                       destPos : Int,
-                       length : Int) {
+                       destPos : Int,                       length : Int) {
     var i = srcPos
     var j = destPos
     val srcUntil = srcPos + length
     while (i < srcUntil) {
@@ -183,134 +172,196 @@
       slowcopy(src, srcPos, dest, destPos, length)
   }
 
   /** Returns an array of length 0 */
-  def empty[T: ClassTag]: Array[T] =  {
-    implicitly[ClassTag[T]].emptyArray
-  }
+  @inline def empty[T: ClassTag]: Array[T] = new Array[T](0)
+
   /** Creates an array with given elements.
-   *
-   *  @param xs the elements to put in the array
+   *   *  @param xs the elements to put in the array
    *  @return an array containing all elements from xs.
    */
   // Subject to a compiler optimization in Cleanup.
   // Array(e0, ..., en) is translated to { val a = new Array(3); a(i) = ei; a }
-  def apply[T: ClassTag](xs: T*): Array[T] = {
-    val len = xs.length
-    xs match {
-      case wa: mutable.WrappedArray[_] if wa.elemTag == classTag[T] =>
-        // We get here in test/files/run/sd760a.scala, `Array[T](t)` for
-        // a specialized type parameter `T`. While we still pay for two
-        // copies of the array it is better than before when we also boxed
-        // each element when populating the result.
-        ScalaRunTime.array_clone(wa.array).asInstanceOf[Array[T]]
-      case _ =>
-        val array = new Array[T](len)
-        var i = 0
-        for (x <- xs.iterator) { array(i) = x; i += 1 }
-        array
-    }
+  def apply[T: ClassTag](xs: T*): Array[T] = xs match {
+    case xs: WrappedArray.ofBoolean =>
+      val from = xs.array
+      val array = new Array[Boolean](from.length)
+      System.arraycopy(from, 0, array, 0, from.length)
+      array.asInstanceOf[Array[T]]
+    case xs: WrappedArray.ofByte =>
+      val from = xs.array
+      val array = new Array[Byte](from.length)
+      System.arraycopy(from, 0, array, 0, from.length)
+      array.asInstanceOf[Array[T]]
+    case xs: WrappedArray.ofShort =>
+      val from = xs.array
+      val array = new Array[Short](from.length)
+      System.arraycopy(from, 0, array, 0, from.length)
+      array.asInstanceOf[Array[T]]
+    case xs: WrappedArray.ofChar =>
+      val from = xs.array
+      val array = new Array[Char](from.length)
+      System.arraycopy(from, 0, array, 0, from.length)
+      array.asInstanceOf[Array[T]]
+    case xs: WrappedArray.ofInt =>
+      val from = xs.array
+      val array = new Array[Int](from.length)
+      System.arraycopy(from, 0, array, 0, from.length)
+      array.asInstanceOf[Array[T]]
+    case xs: WrappedArray.ofLong =>
+      val from = xs.array
+      val array = new Array[Long](from.length)
+      System.arraycopy(from, 0, array, 0, from.length)
+      array.asInstanceOf[Array[T]]
+    case xs: WrappedArray.ofFloat =>
+      val from = xs.array
+      val array = new Array[Float](from.length)
+      System.arraycopy(from, 0, array, 0, from.length)
+      array.asInstanceOf[Array[T]]
+    case xs: WrappedArray.ofDouble =>
+      val from = xs.array
+      val array = new Array[Double](from.length)
+      System.arraycopy(from, 0, array, 0, from.length)
+      array.asInstanceOf[Array[T]]
+    case xs =>
+      val array = new Array[T](xs.length)
+      var i = 0
+      for (x <- xs.iterator) { array(i) = x; i += 1 }
+      array
   }
-
   /** Creates an array of `Boolean` objects */
   // Subject to a compiler optimization in Cleanup, see above.
   def apply(x: Boolean, xs: Boolean*): Array[Boolean] = {
     val array = new Array[Boolean](xs.length + 1)
     array(0) = x
-    var i = 1
-    for (x <- xs.iterator) { array(i) = x; i += 1 }
+    xs match {
+      case xs: WrappedArray.ofBoolean =>
+        System.arraycopy(xs.array, 0, array, 1, xs.array.length)
+      case xs =>
+        var i = 1
+        for (x <- xs.iterator) { array(i) = x; i += 1 }
+    }
     array
   }
-
   /** Creates an array of `Byte` objects */
   // Subject to a compiler optimization in Cleanup, see above.
   def apply(x: Byte, xs: Byte*): Array[Byte] = {
     val array = new Array[Byte](xs.length + 1)
     array(0) = x
-    var i = 1
-    for (x <- xs.iterator) { array(i) = x; i += 1 }
+    xs match {
+      case xs: WrappedArray.ofByte =>
+        System.arraycopy(xs.array, 0, array, 1, xs.array.length)
+      case xs =>
+        var i = 1
+        for (x <- xs.iterator) { array(i) = x; i += 1 }
+    }
     array
   }
-
   /** Creates an array of `Short` objects */
   // Subject to a compiler optimization in Cleanup, see above.
   def apply(x: Short, xs: Short*): Array[Short] = {
     val array = new Array[Short](xs.length + 1)
     array(0) = x
-    var i = 1
-    for (x <- xs.iterator) { array(i) = x; i += 1 }
+    xs match {
+      case xs: WrappedArray.ofShort =>
+        System.arraycopy(xs.array, 0, array, 1, xs.array.length)
+      case xs =>
+        var i = 1
+        for (x <- xs.iterator) { array(i) = x; i += 1 }
+    }
     array
   }
-
   /** Creates an array of `Char` objects */
   // Subject to a compiler optimization in Cleanup, see above.
   def apply(x: Char, xs: Char*): Array[Char] = {
     val array = new Array[Char](xs.length + 1)
     array(0) = x
-    var i = 1
-    for (x <- xs.iterator) { array(i) = x; i += 1 }
+    xs match {
+      case xs: WrappedArray.ofChar =>
+        System.arraycopy(xs.array, 0, array, 1, xs.array.length)
+      case xs =>
+        var i = 1
+        for (x <- xs.iterator) { array(i) = x; i += 1 }
+    }
     array
   }
-
   /** Creates an array of `Int` objects */
   // Subject to a compiler optimization in Cleanup, see above.
   def apply(x: Int, xs: Int*): Array[Int] = {
     val array = new Array[Int](xs.length + 1)
     array(0) = x
-    var i = 1
-    for (x <- xs.iterator) { array(i) = x; i += 1 }
+    xs match {
+      case xs: WrappedArray.ofInt =>
+        System.arraycopy(xs.array, 0, array, 1, xs.array.length)
+      case xs =>
+        var i = 1
+        for (x <- xs.iterator) { array(i) = x; i += 1 }
+    }
     array
   }
-
   /** Creates an array of `Long` objects */
   // Subject to a compiler optimization in Cleanup, see above.
   def apply(x: Long, xs: Long*): Array[Long] = {
     val array = new Array[Long](xs.length + 1)
     array(0) = x
-    var i = 1
-    for (x <- xs.iterator) { array(i) = x; i += 1 }
+    xs match {
+      case xs: WrappedArray.ofLong =>
+        System.arraycopy(xs.array, 0, array, 1, xs.array.length)
+      case xs =>
+        var i = 1
+        for (x <- xs.iterator) { array(i) = x; i += 1 }
+    }
     array
   }
-
   /** Creates an array of `Float` objects */
   // Subject to a compiler optimization in Cleanup, see above.
   def apply(x: Float, xs: Float*): Array[Float] = {
     val array = new Array[Float](xs.length + 1)
     array(0) = x
-    var i = 1
-    for (x <- xs.iterator) { array(i) = x; i += 1 }
+    xs match {
+      case xs: WrappedArray.ofFloat =>
+        System.arraycopy(xs.array, 0, array, 1, xs.array.length)
+      case xs =>
+        var i = 1
+        for (x <- xs.iterator) { array(i) = x; i += 1 }
+    }
     array
   }
-
   /** Creates an array of `Double` objects */
   // Subject to a compiler optimization in Cleanup, see above.
   def apply(x: Double, xs: Double*): Array[Double] = {
     val array = new Array[Double](xs.length + 1)
     array(0) = x
-    var i = 1
-    for (x <- xs.iterator) { array(i) = x; i += 1 }
+    xs match {
+      case xs: WrappedArray.ofDouble =>
+        System.arraycopy(xs.array, 0, array, 1, xs.array.length)
+      case xs =>
+        var i = 1
+        for (x <- xs.iterator) { array(i) = x; i += 1 }
+    }
     array
   }
-
   /** Creates an array of `Unit` objects */
   def apply(x: Unit, xs: Unit*): Array[Unit] = {
     val array = new Array[Unit](xs.length + 1)
     array(0) = x
-    var i = 1
-    for (x <- xs.iterator) { array(i) = x; i += 1 }
+    xs match {
+      case xs: WrappedArray.ofUnit =>
+        System.arraycopy(xs.array, 0, array, 1, xs.array.length)
+      case xs =>
+        var i = 1
+        for (x <- xs.iterator) { array(i) = x; i += 1 }
+    }
     array
   }
-
   /** Creates array with given dimensions */
   def ofDim[T: ClassTag](n1: Int): Array[T] =
     new Array[T](n1)
-  /** Creates a 2-dimensional array */
-  def ofDim[T: ClassTag](n1: Int, n2: Int): Array[Array[T]] = {
+  /** Creates a 2-dimensional array */  def ofDim[T: ClassTag](n1: Int, n2: Int): Array[Array[T]] = {
     val arr: Array[Array[T]] = (new Array[Array[T]](n1): Array[Array[T]])
     for (i <- 0 until n1) arr(i) = new Array[T](n2)
     arr
-    // tabulate(n1)(_ => ofDim[T](n2))
-  }
+    // tabulate(n1)(_ => ofDim[T](n2))  }
   /** Creates a 3-dimensional array */
   def ofDim[T: ClassTag](n1: Int, n2: Int, n3: Int): Array[Array[Array[T]]] =
     tabulate(n1)(_ => ofDim[T](n2, n3))
   /** Creates a 4-dimensional array */
