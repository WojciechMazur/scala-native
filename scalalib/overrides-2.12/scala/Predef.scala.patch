--- scalaSources/2.12.14/scala/Predef.scala
+++ overrides-2.12/scala/Predef.scala
@@ -96,24 +96,21 @@
  * @groupname implicit-classes-any Implicit Classes
  * @groupprio implicit-classes-any 70
  * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.
  *
- * @groupname char-sequence-wrappers CharSequence Wrappers
- * @groupprio char-sequence-wrappers 80
- * @groupdesc char-sequence-wrappers Wrappers that implements CharSequence and were implicit classes.
+ * @groupname implicit-classes-char CharSequence Conversions
+ * @groupprio implicit-classes-char 80
+ * @groupdesc implicit-classes-char These implicit classes add CharSequence methods to Array[Char] and IndexedSeq[Char] instances.
  *
- * @groupname conversions-java-to-anyval Java to Scala
- * @groupprio conversions-java-to-anyval 90
+ * @groupname conversions-java-to-anyval Java to Scala * @groupprio conversions-java-to-anyval 90
  * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.
  *
  * @groupname conversions-anyval-to-java Scala to Java
- * @groupprio conversions-anyval-to-java 100
- * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.
+ * @groupprio conversions-anyval-to-java 100 * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.
  *
  * @groupname conversions-array-to-wrapped-array Array to WrappedArray
  * @groupprio conversions-array-to-wrapped-array 110
- * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to WrappedArrays.
- */
+ * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to WrappedArrays. */
 object Predef extends LowPriorityImplicits with DeprecatedPredef {
   /**
    * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to
    * the class literal `T.class` in Java.
@@ -150,45 +147,40 @@
   type Map[A, +B] = immutable.Map[A, B]
   /**  @group aliases */
   type Set[A]     = immutable.Set[A]
   /**  @group aliases */
-  val Map         = immutable.Map
+  @inline def Map         = immutable.Map
   /**  @group aliases */
-  val Set         = immutable.Set
+  @inline def Set         = immutable.Set
 
-  // Manifest types, companions, and incantations for summoning
-  @annotation.implicitNotFound(msg = "No ClassManifest available for ${T}.")
+  // Manifest types, companions, and incantations for summoning  @annotation.implicitNotFound(msg = "No ClassManifest available for ${T}.")
   @deprecated("use `scala.reflect.ClassTag` instead", "2.10.0")
   type ClassManifest[T] = scala.reflect.ClassManifest[T]
   // TODO undeprecated until Scala reflection becomes non-experimental
-  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
-  type OptManifest[T]   = scala.reflect.OptManifest[T]
+  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")  type OptManifest[T]   = scala.reflect.OptManifest[T]
   @annotation.implicitNotFound(msg = "No Manifest available for ${T}.")
   // TODO undeprecated until Scala reflection becomes non-experimental
   // @deprecated("use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead", "2.10.0")
   type Manifest[T]      = scala.reflect.Manifest[T]
   @deprecated("use `scala.reflect.ClassTag` instead", "2.10.0")
-  val ClassManifest     = scala.reflect.ClassManifest
+  @inline def ClassManifest     = scala.reflect.ClassManifest
   // TODO undeprecated until Scala reflection becomes non-experimental
   // @deprecated("use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead", "2.10.0")
-  val Manifest          = scala.reflect.Manifest
+  @inline def Manifest          = scala.reflect.Manifest
   // TODO undeprecated until Scala reflection becomes non-experimental
   // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
-  val NoManifest        = scala.reflect.NoManifest
+  @inline def NoManifest        = scala.reflect.NoManifest
 
-  // TODO undeprecated until Scala reflection becomes non-experimental
-  // @deprecated("use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead", "2.10.0")
+  // TODO undeprecated until Scala reflection becomes non-experimental  // @deprecated("use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead", "2.10.0")
   def manifest[T](implicit m: Manifest[T])           = m
   @deprecated("use scala.reflect.classTag[T] instead", "2.10.0")
   def classManifest[T](implicit m: ClassManifest[T]) = m
-  // TODO undeprecated until Scala reflection becomes non-experimental
-  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
+  // TODO undeprecated until Scala reflection becomes non-experimental  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
   def optManifest[T](implicit m: OptManifest[T])     = m
 
   // Minor variations on identity functions
+  /** @group utilities */  @inline def identity[A](x: A): A         = x    // @see `conforms` for the implicit version
   /** @group utilities */
-  @inline def identity[A](x: A): A         = x    // @see `conforms` for the implicit version
-  /** @group utilities */
   @inline def implicitly[T](implicit e: T) = e    // for summoning implicit values from the nether world -- TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`
   /** @group utilities */
   @inline def locally[T](x: T): T  = x    // to communicate intent and avoid unmoored statements
 
@@ -348,43 +340,31 @@
   //   instead of the actual argument trees
   // and `@deprecatedName(Symbol("<none>"), "2.12.0")` crashes scalac with
   //   scala.reflect.internal.Symbols$CyclicReference: illegal cyclic reference involving object Symbol
   // in run/repl-no-imports-no-predef-power.scala.
-  /** @group char-sequence-wrappers */
-  final class SeqCharSequence(@deprecated("will be made private", "2.12.0") @deprecatedName(null, "2.12.0") val __sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {
+  /** @group implicit-classes-char */
+  implicit final class SeqCharSequence(@deprecated("will be made private", "2.12.0") @deprecatedName(null, "2.12.0") val __sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {
     def length: Int                                     = __sequenceOfChars.length
-    def charAt(index: Int): Char                        = __sequenceOfChars(index)
-    def subSequence(start: Int, end: Int): CharSequence = new SeqCharSequence(__sequenceOfChars.slice(start, end))
+    def charAt(index: Int): Char                        = __sequenceOfChars(index)    def subSequence(start: Int, end: Int): CharSequence = new SeqCharSequence(__sequenceOfChars.slice(start, end))
     override def toString                               = __sequenceOfChars mkString ""
   }
 
-  /** @group char-sequence-wrappers */
-  def SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]): SeqCharSequence = new SeqCharSequence(sequenceOfChars)
-
-  /** @group char-sequence-wrappers */
-  @deprecated("use `java.nio.CharBuffer.wrap` instead", "2.12.13")
-  final class ArrayCharSequence(@deprecated("will be made private", "2.12.0") @deprecatedName(null, "2.12.0") val __arrayOfChars: Array[Char]) extends CharSequence {
+  /** @group implicit-classes-char */
+  implicit final class ArrayCharSequence(@deprecated("will be made private", "2.12.0") @deprecatedName(null, "2.12.0") val __arrayOfChars: Array[Char]) extends CharSequence {
     def length: Int                                     = __arrayOfChars.length
-    def charAt(index: Int): Char                        = __arrayOfChars(index)
-    def subSequence(start: Int, end: Int): CharSequence = new runtime.ArrayCharSequence(__arrayOfChars, start, end)
+    def charAt(index: Int): Char                        = __arrayOfChars(index)    def subSequence(start: Int, end: Int): CharSequence = new runtime.ArrayCharSequence(__arrayOfChars, start, end)
     override def toString                               = __arrayOfChars mkString ""
   }
 
-  /** @group char-sequence-wrappers */
-  def ArrayCharSequence(arrayOfChars: Array[Char]): ArrayCharSequence = new ArrayCharSequence(arrayOfChars)
-
   implicit val StringCanBuildFrom: CanBuildFrom[String, Char, String] = new CanBuildFrom[String, Char, String] {
-    def apply(from: String) = apply()
-    def apply()             = mutable.StringBuilder.newBuilder
+    def apply(from: String) = apply()    def apply()             = mutable.StringBuilder.newBuilder
   }
 
   /** @group conversions-string */
-  @inline implicit def augmentString(x: String): StringOps = new StringOps(x)
-  /** @group conversions-string */
+  @inline implicit def augmentString(x: String): StringOps = new StringOps(x)  /** @group conversions-string */
   @inline implicit def unaugmentString(x: StringOps): String = x.repr
 
   // printing -----------------------------------------------------------
-
   /** Prints an object to `out` using its `toString` method.
    *
    *  @param x the object to print; may be null.
    *  @group console-output
@@ -553,22 +533,19 @@
   @deprecated("use `Ensuring`", "2.11.0") def any2Ensuring[A](x: A): Ensuring[A]                                            = new Ensuring(x)
   @deprecated("use `StringFormat`", "2.11.0") def any2stringfmt(x: Any): StringFormat[Any]                                  = new StringFormat(x)
   @deprecated("use `Throwable` directly", "2.11.0") def exceptionWrapper(exc: Throwable)                                    = new RichException(exc)
   @deprecated("use `SeqCharSequence`", "2.11.0") def seqToCharSequence(xs: scala.collection.IndexedSeq[Char]): CharSequence = new SeqCharSequence(xs)
-  @deprecated("use `java.nio.CharBuffer.wrap`", "2.11.0") def arrayToCharSequence(xs: Array[Char]): CharSequence = new ArrayCharSequence(xs)
+  @deprecated("use `ArrayCharSequence`", "2.11.0") def arrayToCharSequence(xs: Array[Char]): CharSequence                   = new ArrayCharSequence(xs)
 
-  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLine(): String                 = StdIn.readLine()
-  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLine(text: String, args: Any*) = StdIn.readLine(text, args: _*)
+  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLine(): String                 = StdIn.readLine()  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLine(text: String, args: Any*) = StdIn.readLine(text, args: _*)
   @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readBoolean()                      = StdIn.readBoolean()
   @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readByte()                         = StdIn.readByte()
   @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readShort()                        = StdIn.readShort()
-  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readChar()                         = StdIn.readChar()
-  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readInt()                          = StdIn.readInt()
+  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readChar()                         = StdIn.readChar()  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readInt()                          = StdIn.readInt()
   @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLong()                         = StdIn.readLong()
   @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readFloat()                        = StdIn.readFloat()
   @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readDouble()                       = StdIn.readDouble()
-  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf(format: String)              = StdIn.readf(format)
-  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf1(format: String)             = StdIn.readf1(format)
+  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf(format: String)              = StdIn.readf(format)  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf1(format: String)             = StdIn.readf1(format)
   @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf2(format: String)             = StdIn.readf2(format)
   @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf3(format: String)             = StdIn.readf3(format)
 }
 
