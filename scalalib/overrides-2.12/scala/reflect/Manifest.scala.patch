--- scalaSources/2.12.14/scala/reflect/Manifest.scala
+++ overrides-2.12/scala/reflect/Manifest.scala
@@ -75,22 +75,19 @@
     case _: AnyValManifest[_] => true
     case _                    => false
   }
   override def equals(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]
-  @transient
-  override val hashCode = System.identityHashCode(this)
+  @transient @inline
+  override def hashCode = System.identityHashCode(this)
 }
-
 /** `ManifestFactory` defines factory methods for manifests.
  *  It is intended for use by the compiler and should not be used in client code.
  *
- *  Unlike `Manifest`, this factory isn't annotated with a deprecation warning.
- *  This is done to prevent avalanches of deprecation warnings in the code that calls methods with manifests.
+ *  Unlike `Manifest`, this factory isn't annotated with a deprecation warning. *  This is done to prevent avalanches of deprecation warnings in the code that calls methods with manifests.
  *  Why so complicated? Read up the comments for `ClassManifestFactory`.
  */
 object ManifestFactory {
-  def valueManifests: List[AnyValManifest[_]] =
-    List(Byte, Short, Char, Int, Long, Float, Double, Boolean, Unit)
+  def valueManifests: List[AnyValManifest[_]] =    List(Byte, Short, Char, Int, Long, Float, Double, Boolean, Unit)
 
   @SerialVersionUID(1L)
   private class ByteManifest extends AnyValManifest[scala.Byte]("Byte") {
     def runtimeClass = java.lang.Byte.TYPE
@@ -104,201 +101,175 @@
       }
     }
     private def readResolve(): Any = Manifest.Byte
   }
-  val Byte: AnyValManifest[Byte] = new ByteManifest
+  @inline def Byte: AnyValManifest[Byte] = new ByteManifest
 
-  @SerialVersionUID(1L)
-  private class ShortManifest extends AnyValManifest[scala.Short]("Short") {
+  @SerialVersionUID(1L)  private class ShortManifest extends AnyValManifest[scala.Short]("Short") {
     def runtimeClass = java.lang.Short.TYPE
     override def newArray(len: Int): Array[Short] = new Array[Short](len)
     override def newWrappedArray(len: Int): WrappedArray[Short] = new WrappedArray.ofShort(new Array[Short](len))
-    override def newArrayBuilder(): ArrayBuilder[Short] = new ArrayBuilder.ofShort()
-    override def unapply(x: Any): Option[Short] = {
+    override def newArrayBuilder(): ArrayBuilder[Short] = new ArrayBuilder.ofShort()    override def unapply(x: Any): Option[Short] = {
       x match {
         case d: Short => Some(d)
         case _ => None
       }
     }
     private def readResolve(): Any = Manifest.Short
   }
-  val Short: AnyValManifest[Short] = new ShortManifest
+  @inline def Short: AnyValManifest[Short] = new ShortManifest
 
-  @SerialVersionUID(1L)
-  private class CharManifest extends AnyValManifest[scala.Char]("Char") {
+  @SerialVersionUID(1L)  private class CharManifest extends AnyValManifest[scala.Char]("Char") {
     def runtimeClass = java.lang.Character.TYPE
     override def newArray(len: Int): Array[Char] = new Array[Char](len)
     override def newWrappedArray(len: Int): WrappedArray[Char] = new WrappedArray.ofChar(new Array[Char](len))
-    override def newArrayBuilder(): ArrayBuilder[Char] = new ArrayBuilder.ofChar()
-    override def unapply(x: Any): Option[Char] = {
+    override def newArrayBuilder(): ArrayBuilder[Char] = new ArrayBuilder.ofChar()    override def unapply(x: Any): Option[Char] = {
       x match {
         case d: Char => Some(d)
         case _ => None
       }
     }
     private def readResolve(): Any = Manifest.Char
   }
-  val Char: AnyValManifest[Char] = new CharManifest
+  @inline def Char: AnyValManifest[Char] = new CharManifest
 
-  @SerialVersionUID(1L)
-  private class IntManifest extends AnyValManifest[scala.Int]("Int") {
+  @SerialVersionUID(1L)  private class IntManifest extends AnyValManifest[scala.Int]("Int") {
     def runtimeClass = java.lang.Integer.TYPE
     override def newArray(len: Int): Array[Int] = new Array[Int](len)
     override def newWrappedArray(len: Int): WrappedArray[Int] = new WrappedArray.ofInt(new Array[Int](len))
-    override def newArrayBuilder(): ArrayBuilder[Int] = new ArrayBuilder.ofInt()
-    override def unapply(x: Any): Option[Int] = {
+    override def newArrayBuilder(): ArrayBuilder[Int] = new ArrayBuilder.ofInt()    override def unapply(x: Any): Option[Int] = {
       x match {
         case d: Int => Some(d)
         case _ => None
       }
     }
     private def readResolve(): Any = Manifest.Int
   }
-  val Int: AnyValManifest[Int] = new IntManifest
+  @inline def Int: AnyValManifest[Int] = new IntManifest
 
-  @SerialVersionUID(1L)
-  private class LongManifest extends AnyValManifest[scala.Long]("Long") {
+  @SerialVersionUID(1L)  private class LongManifest extends AnyValManifest[scala.Long]("Long") {
     def runtimeClass = java.lang.Long.TYPE
     override def newArray(len: Int): Array[Long] = new Array[Long](len)
     override def newWrappedArray(len: Int): WrappedArray[Long] = new WrappedArray.ofLong(new Array[Long](len))
-    override def newArrayBuilder(): ArrayBuilder[Long] = new ArrayBuilder.ofLong()
-    override def unapply(x: Any): Option[Long] = {
+    override def newArrayBuilder(): ArrayBuilder[Long] = new ArrayBuilder.ofLong()    override def unapply(x: Any): Option[Long] = {
       x match {
         case d: Long => Some(d)
         case _ => None
       }
     }
     private def readResolve(): Any = Manifest.Long
   }
-  val Long: AnyValManifest[Long] = new LongManifest
+  @inline def Long: AnyValManifest[Long] = new LongManifest
 
-  @SerialVersionUID(1L)
-  private class FloatManifest extends AnyValManifest[scala.Float]("Float") {
+  @SerialVersionUID(1L)  private class FloatManifest extends AnyValManifest[scala.Float]("Float") {
     def runtimeClass = java.lang.Float.TYPE
     override def newArray(len: Int): Array[Float] = new Array[Float](len)
     override def newWrappedArray(len: Int): WrappedArray[Float] = new WrappedArray.ofFloat(new Array[Float](len))
-    override def newArrayBuilder(): ArrayBuilder[Float] = new ArrayBuilder.ofFloat()
-    override def unapply(x: Any): Option[Float] = {
+    override def newArrayBuilder(): ArrayBuilder[Float] = new ArrayBuilder.ofFloat()    override def unapply(x: Any): Option[Float] = {
       x match {
         case d: Float => Some(d)
         case _ => None
       }
     }
     private def readResolve(): Any = Manifest.Float
   }
-  val Float: AnyValManifest[Float] = new FloatManifest
+  @inline def Float: AnyValManifest[Float] = new FloatManifest
 
-  @SerialVersionUID(1L)
-  private class DoubleManifest extends AnyValManifest[scala.Double]("Double") {
+  @SerialVersionUID(1L)  private class DoubleManifest extends AnyValManifest[scala.Double]("Double") {
     def runtimeClass = java.lang.Double.TYPE
     override def newArray(len: Int): Array[Double] = {
       new Array[Double](len)
-    }
-    override def newWrappedArray(len: Int): WrappedArray[Double] = new WrappedArray.ofDouble(new Array[Double](len))
+    }    override def newWrappedArray(len: Int): WrappedArray[Double] = new WrappedArray.ofDouble(new Array[Double](len))
     override def newArrayBuilder(): ArrayBuilder[Double] = new ArrayBuilder.ofDouble()
 
     override def unapply(x: Any): Option[Double] = {
-      x match {
-        case d: Double => Some(d)
+      x match {        case d: Double => Some(d)
         case _ => None
       }
     }
     private def readResolve(): Any = Manifest.Double
   }
-  val Double: AnyValManifest[Double] = new DoubleManifest
+  @inline def Double: AnyValManifest[Double] = new DoubleManifest
 
-  @SerialVersionUID(1L)
-  private class BooleanManifest extends AnyValManifest[scala.Boolean]("Boolean") {
+  @SerialVersionUID(1L)  private class BooleanManifest extends AnyValManifest[scala.Boolean]("Boolean") {
     def runtimeClass = java.lang.Boolean.TYPE
     override def newArray(len: Int): Array[Boolean] = new Array[Boolean](len)
     override def newWrappedArray(len: Int): WrappedArray[Boolean] = new WrappedArray.ofBoolean(new Array[Boolean](len))
-    override def newArrayBuilder(): ArrayBuilder[Boolean] = new ArrayBuilder.ofBoolean()
-    override def unapply(x: Any): Option[Boolean] = {
+    override def newArrayBuilder(): ArrayBuilder[Boolean] = new ArrayBuilder.ofBoolean()    override def unapply(x: Any): Option[Boolean] = {
       x match {
         case d: Boolean => Some(d)
         case _ => None
       }
     }
     private def readResolve(): Any = Manifest.Boolean
   }
-  val Boolean: AnyValManifest[Boolean] = new BooleanManifest
+  @inline def Boolean: AnyValManifest[Boolean] = new BooleanManifest
 
-  @SerialVersionUID(1L)
-  private class UnitManifest extends AnyValManifest[scala.Unit]("Unit") {
+  @SerialVersionUID(1L)  private class UnitManifest extends AnyValManifest[scala.Unit]("Unit") {
     def runtimeClass = java.lang.Void.TYPE
     override def newArray(len: Int): Array[Unit] = new Array[Unit](len)
     override def newWrappedArray(len: Int): WrappedArray[Unit] = new WrappedArray.ofUnit(new Array[Unit](len))
-    override def newArrayBuilder(): ArrayBuilder[Unit] = new ArrayBuilder.ofUnit()
-    override protected def arrayClass[T](tp: Class[_]): Class[Array[T]] =
+    override def newArrayBuilder(): ArrayBuilder[Unit] = new ArrayBuilder.ofUnit()    override protected def arrayClass[T](tp: Class[_]): Class[Array[T]] =
       if (tp eq runtimeClass) classOf[Array[scala.runtime.BoxedUnit]].asInstanceOf[Class[Array[T]]]
       else super.arrayClass(tp)
     override def unapply(x: Any): Option[Unit] = {
-      x match {
-        case d: Unit => Some(d)
+      x match {        case d: Unit => Some(d)
         case _ => None
       }
     }
     private def readResolve(): Any = Manifest.Unit
   }
-  val Unit: AnyValManifest[Unit] = new UnitManifest
+  @inline def Unit: AnyValManifest[Unit] = new UnitManifest
 
-  private val ObjectTYPE = classOf[java.lang.Object]
-  private val NothingTYPE = classOf[scala.runtime.Nothing$]
+  private val ObjectTYPE = classOf[java.lang.Object]  private val NothingTYPE = classOf[scala.runtime.Nothing$]
   private val NullTYPE = classOf[scala.runtime.Null$]
 
   @SerialVersionUID(1L)
   private class AnyManifest extends PhantomManifest[scala.Any](ObjectTYPE, "Any") {
     override def newArray(len: Int) = new Array[scala.Any](len)
     override def <:<(that: ClassManifest[_]): Boolean = (that eq this)
     private def readResolve(): Any = Manifest.Any
   }
-  val Any: Manifest[scala.Any] = new AnyManifest
+  @inline def Any: Manifest[scala.Any] = new AnyManifest
 
-  @SerialVersionUID(1L)
-  private class ObjectManifest extends PhantomManifest[java.lang.Object](ObjectTYPE, "Object") {
+  @SerialVersionUID(1L)  private class ObjectManifest extends PhantomManifest[java.lang.Object](ObjectTYPE, "Object") {
     override def newArray(len: Int) = new Array[java.lang.Object](len)
     override def <:<(that: ClassManifest[_]): Boolean = (that eq this) || (that eq Any)
     private def readResolve(): Any = Manifest.Object
   }
-  val Object: Manifest[java.lang.Object] = new ObjectManifest
+  @inline def Object: Manifest[java.lang.Object] = new ObjectManifest
 
-  val AnyRef: Manifest[scala.AnyRef] = Object.asInstanceOf[Manifest[scala.AnyRef]]
+  @inline def AnyRef: Manifest[scala.AnyRef] = Object.asInstanceOf[Manifest[scala.AnyRef]]
 
-  @SerialVersionUID(1L)
-  private class AnyValPhantomManifest extends PhantomManifest[scala.AnyVal](ObjectTYPE, "AnyVal") {
+  @SerialVersionUID(1L)  private class AnyValPhantomManifest extends PhantomManifest[scala.AnyVal](ObjectTYPE, "AnyVal") {
     override def newArray(len: Int) = new Array[scala.AnyVal](len)
     override def <:<(that: ClassManifest[_]): Boolean = (that eq this) || (that eq Any)
     private def readResolve(): Any = Manifest.AnyVal
   }
-  val AnyVal: Manifest[scala.AnyVal] = new AnyValPhantomManifest
+  @inline def AnyVal: Manifest[scala.AnyVal] = new AnyValPhantomManifest
 
-  @SerialVersionUID(1L)
-  private class NullManifest extends PhantomManifest[scala.Null](NullTYPE, "Null") {
+  @SerialVersionUID(1L)  private class NullManifest extends PhantomManifest[scala.Null](NullTYPE, "Null") {
     override def newArray(len: Int) = new Array[scala.Null](len)
     override def <:<(that: ClassManifest[_]): Boolean =
       (that ne null) && (that ne Nothing) && !(that <:< AnyVal)
     private def readResolve(): Any = Manifest.Null
   }
-  val Null: Manifest[scala.Null] = new NullManifest
+  @inline def Null: Manifest[scala.Null] = new NullManifest
 
-  @SerialVersionUID(1L)
-  private class NothingManifest extends PhantomManifest[scala.Nothing](NothingTYPE, "Nothing") {
+  @SerialVersionUID(1L)  private class NothingManifest extends PhantomManifest[scala.Nothing](NothingTYPE, "Nothing") {
     override def newArray(len: Int) = new Array[scala.Nothing](len)
     override def <:<(that: ClassManifest[_]): Boolean = (that ne null)
     private def readResolve(): Any = Manifest.Nothing
   }
-  val Nothing: Manifest[scala.Nothing] = new NothingManifest
+  @inline def Nothing: Manifest[scala.Nothing] = new NothingManifest
 
-  @SerialVersionUID(1L)
-  private class SingletonTypeManifest[T <: AnyRef](value: AnyRef) extends Manifest[T] {
+  @SerialVersionUID(1L)  private class SingletonTypeManifest[T <: AnyRef](value: AnyRef) extends Manifest[T] {
     lazy val runtimeClass = value.getClass
     override lazy val toString = value.toString + ".type"
   }
-
   /** Manifest for the singleton type `value.type`. */
   def singleType[T <: AnyRef](value: AnyRef): Manifest[T] =
     new SingletonTypeManifest[T](value)
-
   /** Manifest for the class type `clazz[args]`, where `clazz` is
     * a top-level or static class.
     * @note This no-prefix, no-arguments case is separate because we
     *       it's called from ScalaRunTime.boxArray itself. If we
@@ -322,22 +293,19 @@
   @SerialVersionUID(1L)
   private abstract class PhantomManifest[T](_runtimeClass: Predef.Class[_],
                                             override val toString: String) extends ClassTypeManifest[T](None, _runtimeClass, Nil) {
     override def equals(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]
-    @transient
-    override val hashCode = System.identityHashCode(this)
+    @transient @inline
+    override def hashCode = System.identityHashCode(this)
   }
-
   /** Manifest for the class type `clazz[args]`, where `clazz` is
     * a top-level or static class. */
   @SerialVersionUID(1L)
-  private class ClassTypeManifest[T](prefix: Option[Manifest[_]],
-                                     val runtimeClass: Predef.Class[_],
+  private class ClassTypeManifest[T](prefix: Option[Manifest[_]],                                     val runtimeClass: Predef.Class[_],
                                      override val typeArguments: List[Manifest[_]]) extends Manifest[T] {
     override def toString =
       (if (prefix.isEmpty) "" else prefix.get.toString+"#") +
-      (if (runtimeClass.isArray) "Array" else runtimeClass.getName) +
-      argString
+      (if (runtimeClass.isArray) "Array" else runtimeClass.getName) +      argString
    }
 
   def arrayType[T](arg: Manifest[_]): Manifest[Array[T]] =
     arg.asInstanceOf[Manifest[T]].arrayManifest
