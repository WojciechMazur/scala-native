--- 2.13.6/scala/reflect/Manifest.scala
+++ overrides-2.13/scala/reflect/Manifest.scala
@@ -83,1 +83,1 @@
-    ManifestFactory.valueManifests
+	ManifestFactory.valueManifests
@@ -85,9 +85,9 @@
-  val Byte: ManifestFactory.ByteManifest = ManifestFactory.Byte
-  val Short: ManifestFactory.ShortManifest = ManifestFactory.Short
-  val Char: ManifestFactory.CharManifest = ManifestFactory.Char
-  val Int: ManifestFactory.IntManifest = ManifestFactory.Int
-  val Long: ManifestFactory.LongManifest = ManifestFactory.Long
-  val Float: ManifestFactory.FloatManifest = ManifestFactory.Float
-  val Double: ManifestFactory.DoubleManifest = ManifestFactory.Double
-  val Boolean: ManifestFactory.BooleanManifest = ManifestFactory.Boolean
-  val Unit: ManifestFactory.UnitManifest = ManifestFactory.Unit
+  @inline def Byte: ManifestFactory.ByteManifest = ManifestFactory.Byte
+  @inline def Short: ManifestFactory.ShortManifest = ManifestFactory.Short
+  @inline def Char: ManifestFactory.CharManifest = ManifestFactory.Char
+  @inline def Int: ManifestFactory.IntManifest = ManifestFactory.Int
+  @inline def Long: ManifestFactory.LongManifest = ManifestFactory.Long
+  @inline def Float: ManifestFactory.FloatManifest = ManifestFactory.Float
+  @inline def Double: ManifestFactory.DoubleManifest = ManifestFactory.Double
+  @inline def Boolean: ManifestFactory.BooleanManifest = ManifestFactory.Boolean
+  @inline def Unit: ManifestFactory.UnitManifest = ManifestFactory.Unit
@@ -95,6 +95,6 @@
-  val Any: Manifest[scala.Any] = ManifestFactory.Any
-  val Object: Manifest[java.lang.Object] = ManifestFactory.Object
-  val AnyRef: Manifest[scala.AnyRef] = ManifestFactory.AnyRef
-  val AnyVal: Manifest[scala.AnyVal] = ManifestFactory.AnyVal
-  val Null: Manifest[scala.Null] = ManifestFactory.Null
-  val Nothing: Manifest[scala.Nothing] = ManifestFactory.Nothing
+  @inline def Any: Manifest[scala.Any] = ManifestFactory.Any
+  @inline def Object: Manifest[java.lang.Object] = ManifestFactory.Object
+  @inline def AnyRef: Manifest[scala.AnyRef] = ManifestFactory.AnyRef
+  @inline def AnyVal: Manifest[scala.AnyVal] = ManifestFactory.AnyVal
+  @inline def Null: Manifest[scala.Null] = ManifestFactory.Null
+  @inline def Nothing: Manifest[scala.Nothing] = ManifestFactory.Nothing
@@ -104,1 +104,1 @@
-    ManifestFactory.singleType[T](value)
+	ManifestFactory.singleType[T](value)
@@ -107,6 +107,6 @@
-    * a top-level or static class.
-    * @note This no-prefix, no-arguments case is separate because we
-    *       it's called from ScalaRunTime.boxArray itself. If we
-    *       pass varargs as arrays into this, we get an infinitely recursive call
-    *       to boxArray. (Besides, having a separate case is more efficient)
-    */
+   * a top-level or static class.
+   * @note This no-prefix, no-arguments case is separate because we
+   *       it's called from ScalaRunTime.boxArray itself. If we
+   *       pass varargs as arrays into this, we get an infinitely recursive call
+   *       to boxArray. (Besides, having a separate case is more efficient)
+   */
@@ -114,1 +114,1 @@
-    ManifestFactory.classType[T](clazz)
+	ManifestFactory.classType[T](clazz)
@@ -117,1 +117,1 @@
-    * a top-level or static class and args are its type arguments. */
+   * a top-level or static class and args are its type arguments. */
@@ -119,1 +119,1 @@
-    ManifestFactory.classType[T](clazz, arg1, args: _*)
+	ManifestFactory.classType[T](clazz, arg1, args: _*)
@@ -122,2 +122,2 @@
-    * a class with non-package prefix type `prefix` and type arguments `args`.
-    */
+   * a class with non-package prefix type `prefix` and type arguments `args`.
+   */
@@ -125,1 +125,1 @@
-    ManifestFactory.classType[T](prefix, clazz, args: _*)
+	ManifestFactory.classType[T](prefix, clazz, args: _*)
@@ -128,1 +128,1 @@
-    ManifestFactory.arrayType[T](arg)
+	ManifestFactory.arrayType[T](arg)
@@ -131,2 +131,2 @@
-    * strictly necessary as it could be obtained by reflection. It was
-    * added so that erasure can be calculated without reflection. */
+   * strictly necessary as it could be obtained by reflection. It was
+   * added so that erasure can be calculated without reflection. */
@@ -134,1 +134,1 @@
-    ManifestFactory.abstractType[T](prefix, name, upperBound, args: _*)
+	ManifestFactory.abstractType[T](prefix, name, upperBound, args: _*)
@@ -138,1 +138,1 @@
-    ManifestFactory.wildcardType[T](lowerBound, upperBound)
+	ManifestFactory.wildcardType[T](lowerBound, upperBound)
@@ -142,1 +142,1 @@
-    ManifestFactory.intersectionType[T](parents: _*)
+	ManifestFactory.intersectionType[T](parents: _*)
@@ -145,1 +145,0 @@
-
@@ -148,1 +147,0 @@
-@nowarn("""cat=deprecation&origin=scala\.reflect\.ClassManifest(DeprecatedApis.*)?""")
@@ -152,1 +150,1 @@
-    (that eq this) || (that eq Manifest.Any) || (that eq Manifest.AnyVal)
+	(that eq this) || (that eq Manifest.Any) || (that eq Manifest.AnyVal)
@@ -154,2 +152,2 @@
-    case _: AnyValManifest[_] => true
-    case _                    => false
+	case _: AnyValManifest[_] => true
+	case _                    => false
@@ -157,2 +155,1 @@
-  override def equals(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]
-  @transient
+  override def equals(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]  @transient
@@ -162,2 +159,1 @@
-/** `ManifestFactory` defines factory methods for manifests.
- *  It is intended for use by the compiler and should not be used in client code.
+/** `ManifestFactory` defines factory methods for manifests. *  It is intended for use by the compiler and should not be used in client code.
@@ -169,1 +165,0 @@
-@nowarn("""cat=deprecation&origin=scala\.reflect\.ClassManifest(DeprecatedApis.*)?""")
@@ -172,1 +167,1 @@
-    List(Byte, Short, Char, Int, Long, Float, Double, Boolean, Unit)
+	List(Byte, Short, Char, Int, Long, Float, Double, Boolean, Unit)
@@ -175,12 +170,12 @@
-  final private[reflect] class ByteManifest extends AnyValManifest[scala.Byte]("Byte") {
-    def runtimeClass = java.lang.Byte.TYPE
-    @inline override def newArray(len: Int): Array[Byte] = new Array[Byte](len)
-    override def newWrappedArray(len: Int): ArraySeq[Byte] = new ArraySeq.ofByte(new Array[Byte](len))
-    override def newArrayBuilder(): ArrayBuilder[Byte] = new ArrayBuilder.ofByte()
-    override def unapply(x: Any): Option[Byte] = {
-      x match {
-        case d: Byte => Some(d)
-        case _ => None
-      }
-    }
-    private def readResolve(): Any = Manifest.Byte
+  private[reflect] class ByteManifest extends AnyValManifest[scala.Byte]("Byte") {
+	def runtimeClass = java.lang.Byte.TYPE
+	@inline override def newArray(len: Int): Array[Byte] = new Array[Byte](len)
+	override def newWrappedArray(len: Int): ArraySeq[Byte] = new ArraySeq.ofByte(new Array[Byte](len))
+	override def newArrayBuilder(): ArrayBuilder[Byte] = new ArrayBuilder.ofByte()
+	override def unapply(x: Any): Option[Byte] = {
+	  x match {
+		case d: Byte => Some(d)
+		case _ => None
+	  }
+	}
+	private def readResolve(): Any = Manifest.Byte
@@ -188,1 +183,2 @@
-  val Byte: ByteManifest = new ByteManifest
+  private object ByteManifest extends ByteManifest
+  def Byte: ByteManifest = ByteManifest
@@ -191,12 +187,12 @@
-  final private[reflect] class ShortManifest extends AnyValManifest[scala.Short]("Short") {
-    def runtimeClass = java.lang.Short.TYPE
-    @inline override def newArray(len: Int): Array[Short] = new Array[Short](len)
-    override def newWrappedArray(len: Int): ArraySeq[Short] = new ArraySeq.ofShort(new Array[Short](len))
-    override def newArrayBuilder(): ArrayBuilder[Short] = new ArrayBuilder.ofShort()
-    override def unapply(x: Any): Option[Short] = {
-      x match {
-        case d: Short => Some(d)
-        case _ => None
-      }
-    }
-    private def readResolve(): Any = Manifest.Short
+  private[reflect] class ShortManifest extends AnyValManifest[scala.Short]("Short") {
+	def runtimeClass = java.lang.Short.TYPE
+	@inline override def newArray(len: Int): Array[Short] = new Array[Short](len)
+	override def newWrappedArray(len: Int): ArraySeq[Short] = new ArraySeq.ofShort(new Array[Short](len))
+	override def newArrayBuilder(): ArrayBuilder[Short] = new ArrayBuilder.ofShort()
+	override def unapply(x: Any): Option[Short] = {
+	  x match {
+		case d: Short => Some(d)
+		case _ => None
+	  }
+	}
+	private def readResolve(): Any = Manifest.Short
@@ -204,1 +200,2 @@
-  val Short: ShortManifest = new ShortManifest
+  private object ShortManifest extends ShortManifest
+  def Short: ShortManifest = ShortManifest
@@ -207,12 +204,12 @@
-  final private[reflect] class CharManifest extends AnyValManifest[scala.Char]("Char") {
-    def runtimeClass = java.lang.Character.TYPE
-    @inline override def newArray(len: Int): Array[Char] = new Array[Char](len)
-    override def newWrappedArray(len: Int): ArraySeq[Char] = new ArraySeq.ofChar(new Array[Char](len))
-    override def newArrayBuilder(): ArrayBuilder[Char] = new ArrayBuilder.ofChar()
-    override def unapply(x: Any): Option[Char] = {
-      x match {
-        case d: Char => Some(d)
-        case _ => None
-      }
-    }
-    private def readResolve(): Any = Manifest.Char
+  private[reflect] class CharManifest extends AnyValManifest[scala.Char]("Char") {
+	def runtimeClass = java.lang.Character.TYPE
+	@inline override def newArray(len: Int): Array[Char] = new Array[Char](len)
+	override def newWrappedArray(len: Int): ArraySeq[Char] = new ArraySeq.ofChar(new Array[Char](len))
+	override def newArrayBuilder(): ArrayBuilder[Char] = new ArrayBuilder.ofChar()
+	override def unapply(x: Any): Option[Char] = {
+	  x match {
+		case d: Char => Some(d)
+		case _ => None
+	  }
+	}
+	private def readResolve(): Any = Manifest.Char
@@ -220,1 +217,2 @@
-  val Char: CharManifest = new CharManifest
+  private object CharManifest extends CharManifest
+  def Char: CharManifest = CharManifest
@@ -223,12 +221,12 @@
-  final private[reflect] class IntManifest extends AnyValManifest[scala.Int]("Int") {
-    def runtimeClass = java.lang.Integer.TYPE
-    @inline override def newArray(len: Int): Array[Int] = new Array[Int](len)
-    override def newWrappedArray(len: Int): ArraySeq[Int] = new ArraySeq.ofInt(new Array[Int](len))
-    override def newArrayBuilder(): ArrayBuilder[Int] = new ArrayBuilder.ofInt()
-    override def unapply(x: Any): Option[Int] = {
-      x match {
-        case d: Int => Some(d)
-        case _ => None
-      }
-    }
-    private def readResolve(): Any = Manifest.Int
+  private[reflect] class IntManifest extends AnyValManifest[scala.Int]("Int") {
+	def runtimeClass = java.lang.Integer.TYPE
+	@inline override def newArray(len: Int): Array[Int] = new Array[Int](len)
+	override def newWrappedArray(len: Int): ArraySeq[Int] = new ArraySeq.ofInt(new Array[Int](len))
+	override def newArrayBuilder(): ArrayBuilder[Int] = new ArrayBuilder.ofInt()
+	override def unapply(x: Any): Option[Int] = {
+	  x match {
+		case d: Int => Some(d)
+		case _ => None
+	  }
+	}
+	private def readResolve(): Any = Manifest.Int
@@ -236,1 +234,2 @@
-  val Int: IntManifest = new IntManifest
+  private object IntManifest extends IntManifest
+  def Int: IntManifest = IntManifest
@@ -239,12 +238,12 @@
-  final private[reflect] class LongManifest extends AnyValManifest[scala.Long]("Long") {
-    def runtimeClass = java.lang.Long.TYPE
-    @inline override def newArray(len: Int): Array[Long] = new Array[Long](len)
-    override def newWrappedArray(len: Int): ArraySeq[Long] = new ArraySeq.ofLong(new Array[Long](len))
-    override def newArrayBuilder(): ArrayBuilder[Long] = new ArrayBuilder.ofLong()
-    override def unapply(x: Any): Option[Long] = {
-      x match {
-        case d: Long => Some(d)
-        case _ => None
-      }
-    }
-    private def readResolve(): Any = Manifest.Long
+  private[reflect] class LongManifest extends AnyValManifest[scala.Long]("Long") {
+	def runtimeClass = java.lang.Long.TYPE
+	@inline override def newArray(len: Int): Array[Long] = new Array[Long](len)
+	override def newWrappedArray(len: Int): ArraySeq[Long] = new ArraySeq.ofLong(new Array[Long](len))
+	override def newArrayBuilder(): ArrayBuilder[Long] = new ArrayBuilder.ofLong()
+	override def unapply(x: Any): Option[Long] = {
+	  x match {
+		case d: Long => Some(d)
+		case _ => None
+	  }
+	}
+	private def readResolve(): Any = Manifest.Long
@@ -252,1 +251,2 @@
-  val Long: LongManifest = new LongManifest
+  private object LongManifest extends LongManifest
+  def Long: LongManifest = LongManifest
@@ -255,12 +255,12 @@
-  final private[reflect] class FloatManifest extends AnyValManifest[scala.Float]("Float") {
-    def runtimeClass = java.lang.Float.TYPE
-    @inline override def newArray(len: Int): Array[Float] = new Array[Float](len)
-    override def newWrappedArray(len: Int): ArraySeq[Float] = new ArraySeq.ofFloat(new Array[Float](len))
-    override def newArrayBuilder(): ArrayBuilder[Float] = new ArrayBuilder.ofFloat()
-    override def unapply(x: Any): Option[Float] = {
-      x match {
-        case d: Float => Some(d)
-        case _ => None
-      }
-    }
-    private def readResolve(): Any = Manifest.Float
+  private[reflect] class FloatManifest extends AnyValManifest[scala.Float]("Float") {
+	def runtimeClass = java.lang.Float.TYPE
+	@inline override def newArray(len: Int): Array[Float] = new Array[Float](len)
+	override def newWrappedArray(len: Int): ArraySeq[Float] = new ArraySeq.ofFloat(new Array[Float](len))
+	override def newArrayBuilder(): ArrayBuilder[Float] = new ArrayBuilder.ofFloat()
+	override def unapply(x: Any): Option[Float] = {
+	  x match {
+		case d: Float => Some(d)
+		case _ => None
+	  }
+	}
+	private def readResolve(): Any = Manifest.Float
@@ -268,1 +268,2 @@
-  val Float: FloatManifest = new FloatManifest
+  private object FloatManifest extends FloatManifest
+  def Float: FloatManifest = FloatManifest
@@ -271,5 +272,5 @@
-  final private[reflect] class DoubleManifest extends AnyValManifest[scala.Double]("Double") {
-    def runtimeClass = java.lang.Double.TYPE
-    @inline override def newArray(len: Int): Array[Double] = new Array[Double](len)
-    override def newWrappedArray(len: Int): ArraySeq[Double] = new ArraySeq.ofDouble(new Array[Double](len))
-    override def newArrayBuilder(): ArrayBuilder[Double] = new ArrayBuilder.ofDouble()
+  private[reflect] class DoubleManifest extends AnyValManifest[scala.Double]("Double") {
+	def runtimeClass = java.lang.Double.TYPE
+	@inline override def newArray(len: Int): Array[Double] = new Array[Double](len)
+	override def newWrappedArray(len: Int): ArraySeq[Double] = new ArraySeq.ofDouble(new Array[Double](len))
+	override def newArrayBuilder(): ArrayBuilder[Double] = new ArrayBuilder.ofDouble()
@@ -277,7 +278,7 @@
-    override def unapply(x: Any): Option[Double] = {
-      x match {
-        case d: Double => Some(d)
-        case _ => None
-      }
-    }
-    private def readResolve(): Any = Manifest.Double
+	override def unapply(x: Any): Option[Double] = {
+	  x match {
+		case d: Double => Some(d)
+		case _ => None
+	  }
+	}
+	private def readResolve(): Any = Manifest.Double
@@ -285,1 +286,2 @@
-  val Double: DoubleManifest = new DoubleManifest
+  private object DoubleManifest extends DoubleManifest
+  def Double: DoubleManifest = DoubleManifest
@@ -288,12 +290,12 @@
-  final private[reflect] class BooleanManifest extends AnyValManifest[scala.Boolean]("Boolean") {
-    def runtimeClass = java.lang.Boolean.TYPE
-    @inline override def newArray(len: Int): Array[Boolean] = new Array[Boolean](len)
-    override def newWrappedArray(len: Int): ArraySeq[Boolean] = new ArraySeq.ofBoolean(new Array[Boolean](len))
-    override def newArrayBuilder(): ArrayBuilder[Boolean] = new ArrayBuilder.ofBoolean()
-    override def unapply(x: Any): Option[Boolean] = {
-      x match {
-        case d: Boolean => Some(d)
-        case _ => None
-      }
-    }
-    private def readResolve(): Any = Manifest.Boolean
+  private[reflect] class BooleanManifest extends AnyValManifest[scala.Boolean]("Boolean") {
+	def runtimeClass = java.lang.Boolean.TYPE
+	@inline override def newArray(len: Int): Array[Boolean] = new Array[Boolean](len)
+	override def newWrappedArray(len: Int): ArraySeq[Boolean] = new ArraySeq.ofBoolean(new Array[Boolean](len))
+	override def newArrayBuilder(): ArrayBuilder[Boolean] = new ArrayBuilder.ofBoolean()
+	override def unapply(x: Any): Option[Boolean] = {
+	  x match {
+		case d: Boolean => Some(d)
+		case _ => None
+	  }
+	}
+	private def readResolve(): Any = Manifest.Boolean
@@ -301,1 +303,2 @@
-  val Boolean: BooleanManifest = new BooleanManifest
+  private object BooleanManifest extends BooleanManifest
+  def Boolean: BooleanManifest = BooleanManifest
@@ -304,15 +307,15 @@
-  final private[reflect] class UnitManifest extends AnyValManifest[scala.Unit]("Unit") {
-    def runtimeClass = java.lang.Void.TYPE
-    @inline override def newArray(len: Int): Array[Unit] = new Array[Unit](len)
-    override def newWrappedArray(len: Int): ArraySeq[Unit] = new ArraySeq.ofUnit(new Array[Unit](len))
-    override def newArrayBuilder(): ArrayBuilder[Unit] = new ArrayBuilder.ofUnit()
-    override protected def arrayClass[T](tp: Class[_]): Class[Array[T]] =
-      if (tp eq runtimeClass) classOf[Array[scala.runtime.BoxedUnit]].asInstanceOf[Class[Array[T]]]
-      else super.arrayClass(tp)
-    override def unapply(x: Any): Option[Unit] = {
-      x match {
-        case d: Unit => Some(d)
-        case _ => None
-      }
-    }
-    private def readResolve(): Any = Manifest.Unit
+  private[reflect] class UnitManifest extends AnyValManifest[scala.Unit]("Unit") {
+	def runtimeClass = java.lang.Void.TYPE
+	@inline override def newArray(len: Int): Array[Unit] = new Array[Unit](len)
+	override def newWrappedArray(len: Int): ArraySeq[Unit] = new ArraySeq.ofUnit(new Array[Unit](len))
+	override def newArrayBuilder(): ArrayBuilder[Unit] = new ArrayBuilder.ofUnit()
+	override protected def arrayClass[T](tp: Class[_]): Class[Array[T]] =
+	  if (tp eq runtimeClass) classOf[Array[scala.runtime.BoxedUnit]].asInstanceOf[Class[Array[T]]]
+	  else super.arrayClass(tp)
+	override def unapply(x: Any): Option[Unit] = {
+	  x match {
+		case d: Unit => Some(d)
+		case _ => None
+	  }
+	}
+	private def readResolve(): Any = Manifest.Unit
@@ -320,1 +323,2 @@
-  val Unit: UnitManifest = new UnitManifest
+  private object UnitManifest extends UnitManifest
+  def Unit: UnitManifest = UnitManifest
@@ -322,9 +326,5 @@
-  private[this] val ObjectTYPE = classOf[java.lang.Object]
-  private[this] val NothingTYPE = classOf[scala.runtime.Nothing$]
-  private[this] val NullTYPE = classOf[scala.runtime.Null$]
-
-  @SerialVersionUID(1L)
-  final private class AnyManifest extends PhantomManifest[scala.Any](ObjectTYPE, "Any") {
-    override def newArray(len: Int) = new Array[scala.Any](len)
-    override def <:<(that: ClassManifest[_]): Boolean = (that eq this)
-    private def readResolve(): Any = Manifest.Any
+  private object AnyManifest extends PhantomManifest[scala.Any](classOf[java.lang.Object], "Any") {
+	override def runtimeClass = classOf[java.lang.Object]
+	override def newArray(len: Int) = new Array[scala.Any](len)
+	override def <:<(that: ClassManifest[_]): Boolean = (that eq this)
+	private def readResolve(): Any = Manifest.Any
@@ -332,1 +332,1 @@
-  val Any: Manifest[scala.Any] = new AnyManifest
+  def Any: Manifest[scala.Any] = AnyManifest
@@ -334,5 +334,5 @@
-  @SerialVersionUID(1L)
-  final private class ObjectManifest extends PhantomManifest[java.lang.Object](ObjectTYPE, "Object") {
-    override def newArray(len: Int) = new Array[java.lang.Object](len)
-    override def <:<(that: ClassManifest[_]): Boolean = (that eq this) || (that eq Any)
-    private def readResolve(): Any = Manifest.Object
+  private object ObjectManifest extends PhantomManifest[java.lang.Object](classOf[java.lang.Object], "Object") {
+	override def runtimeClass = classOf[java.lang.Object]
+	override def newArray(len: Int) = new Array[java.lang.Object](len)
+	override def <:<(that: ClassManifest[_]): Boolean = (that eq this) || (that eq Any)
+	private def readResolve(): Any = Manifest.Object
@@ -340,1 +340,1 @@
-  val Object: Manifest[java.lang.Object] = new ObjectManifest
+  def Object: Manifest[java.lang.Object] = ObjectManifest
@@ -342,1 +342,1 @@
-  val AnyRef: Manifest[scala.AnyRef] = Object.asInstanceOf[Manifest[scala.AnyRef]]
+  def AnyRef: Manifest[scala.AnyRef] = Object.asInstanceOf[Manifest[scala.AnyRef]]
@@ -344,5 +344,5 @@
-  @SerialVersionUID(1L)
-  final private class AnyValPhantomManifest extends PhantomManifest[scala.AnyVal](ObjectTYPE, "AnyVal") {
-    override def newArray(len: Int) = new Array[scala.AnyVal](len)
-    override def <:<(that: ClassManifest[_]): Boolean = (that eq this) || (that eq Any)
-    private def readResolve(): Any = Manifest.AnyVal
+  private object AnyValManifest extends PhantomManifest[scala.AnyVal](classOf[java.lang.Object], "AnyVal") {
+	override def runtimeClass = classOf[java.lang.Object]
+	override def newArray(len: Int) = new Array[scala.AnyVal](len)
+	override def <:<(that: ClassManifest[_]): Boolean = (that eq this) || (that eq Any)
+	private def readResolve(): Any = Manifest.AnyVal
@@ -350,1 +350,1 @@
-  val AnyVal: Manifest[scala.AnyVal] = new AnyValPhantomManifest
+  def AnyVal: Manifest[scala.AnyVal] = AnyValManifest
@@ -352,6 +352,6 @@
-  @SerialVersionUID(1L)
-  final private class NullManifest extends PhantomManifest[scala.Null](NullTYPE, "Null") {
-    override def newArray(len: Int) = new Array[scala.Null](len)
-    override def <:<(that: ClassManifest[_]): Boolean =
-      (that ne null) && (that ne Nothing) && !(that <:< AnyVal)
-    private def readResolve(): Any = Manifest.Null
+  private object NullManifest extends PhantomManifest[scala.Null](classOf[scala.runtime.Null$], "Null") {
+	override def runtimeClass = classOf[scala.runtime.Null$]
+	override def newArray(len: Int) = new Array[scala.Null](len)
+	override def <:<(that: ClassManifest[_]): Boolean =
+	  (that ne null) && (that ne Nothing) && !(that <:< AnyVal)
+	private def readResolve(): Any = Manifest.Null
@@ -359,1 +359,1 @@
-  val Null: Manifest[scala.Null] = new NullManifest
+  def Null: Manifest[scala.Null] = NullManifest
@@ -361,5 +361,5 @@
-  @SerialVersionUID(1L)
-  final private class NothingManifest extends PhantomManifest[scala.Nothing](NothingTYPE, "Nothing") {
-    override def newArray(len: Int) = new Array[scala.Nothing](len)
-    override def <:<(that: ClassManifest[_]): Boolean = (that ne null)
-    private def readResolve(): Any = Manifest.Nothing
+  private object NothingManifest extends PhantomManifest[scala.Nothing](classOf[scala.runtime.Nothing$], "Nothing") {
+	override def runtimeClass = classOf[scala.runtime.Nothing$]
+	override def newArray(len: Int) = new Array[scala.Nothing](len)
+	override def <:<(that: ClassManifest[_]): Boolean = (that ne null)
+	private def readResolve(): Any = Manifest.Nothing
@@ -367,1 +367,1 @@
-  val Nothing: Manifest[scala.Nothing] = new NothingManifest
+  def Nothing: Manifest[scala.Nothing] = NothingManifest
@@ -370,3 +370,3 @@
-  final private class SingletonTypeManifest[T <: AnyRef](value: AnyRef) extends Manifest[T] {
-    lazy val runtimeClass = value.getClass
-    override lazy val toString = value.toString + ".type"
+  private class SingletonTypeManifest[T <: AnyRef](value: AnyRef) extends Manifest[T] {
+	lazy val runtimeClass = value.getClass
+	override lazy val toString = value.toString + ".type"
@@ -377,1 +377,1 @@
-    new SingletonTypeManifest[T](value)
+	new SingletonTypeManifest[T](value)
@@ -380,6 +380,6 @@
-    * a top-level or static class.
-    * @note This no-prefix, no-arguments case is separate because we
-    *       it's called from ScalaRunTime.boxArray itself. If we
-    *       pass varargs as arrays into this, we get an infinitely recursive call
-    *       to boxArray. (Besides, having a separate case is more efficient)
-    */
+   * a top-level or static class.
+   * @note This no-prefix, no-arguments case is separate because we
+   *       it's called from ScalaRunTime.boxArray itself. If we
+   *       pass varargs as arrays into this, we get an infinitely recursive call
+   *       to boxArray. (Besides, having a separate case is more efficient)
+   */
@@ -387,1 +387,1 @@
-    new ClassTypeManifest[T](None, clazz, Nil)
+	new ClassTypeManifest[T](None, clazz, Nil)
@@ -390,1 +390,1 @@
-    * a top-level or static class and args are its type arguments. */
+   * a top-level or static class and args are its type arguments. */
@@ -392,1 +392,1 @@
-    new ClassTypeManifest[T](None, clazz, arg1 :: args.toList)
+	new ClassTypeManifest[T](None, clazz, arg1 :: args.toList)
@@ -395,2 +395,2 @@
-    * a class with non-package prefix type `prefix` and type arguments `args`.
-    */
+   * a class with non-package prefix type `prefix` and type arguments `args`.
+   */
@@ -398,1 +398,1 @@
-    new ClassTypeManifest[T](Some(prefix), clazz, args.toList)
+	new ClassTypeManifest[T](Some(prefix), clazz, args.toList)
@@ -402,4 +402,4 @@
-                                            override val toString: String) extends ClassTypeManifest[T](None, _runtimeClass, Nil) {
-    override def equals(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]
-    @transient
-    override val hashCode = System.identityHashCode(this)
+	override val toString: String) extends ClassTypeManifest[T](None, _runtimeClass, Nil) {
+	override def equals(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]
+	@transient
+	override val hashCode = System.identityHashCode(this)
@@ -409,1 +409,1 @@
-    * a top-level or static class. */
+   * a top-level or static class. */
@@ -412,7 +412,8 @@
-                                     val runtimeClass: Predef.Class[_],
-                                     override val typeArguments: List[Manifest[_]]) extends Manifest[T] {
-    override def toString =
-      (if (prefix.isEmpty) "" else prefix.get.toString+"#") +
-      (if (runtimeClass.isArray) "Array" else runtimeClass.getName) +
-      argString
-   }
+	runtimeClass1: Predef.Class[_],
+	override val typeArguments: List[Manifest[_]]) extends Manifest[T] {
+	def runtimeClass: Predef.Class[_] = runtimeClass1
+	override def toString =
+	  (if (prefix.isEmpty) "" else prefix.get.toString+"#") +
+		(if (runtimeClass.isArray) "Array" else runtimeClass.getName) +
+		argString
+  }
@@ -421,1 +422,1 @@
-    arg.asInstanceOf[Manifest[T]].arrayManifest
+	arg.asInstanceOf[Manifest[T]].arrayManifest
@@ -425,3 +426,3 @@
-    def runtimeClass = upperBound
-    override val typeArguments = args.toList
-    override def toString = prefix.toString+"#"+name+argString
+	def runtimeClass = upperBound
+	override val typeArguments = args.toList
+	override def toString = prefix.toString+"#"+name+argString
@@ -431,2 +432,2 @@
-    * strictly necessary as it could be obtained by reflection. It was
-    * added so that erasure can be calculated without reflection. */
+   * strictly necessary as it could be obtained by reflection. It was
+   * added so that erasure can be calculated without reflection. */
@@ -434,1 +435,1 @@
-    new AbstractTypeManifest[T](prefix, name, upperBound, args)
+	new AbstractTypeManifest[T](prefix, name, upperBound, args)
@@ -438,5 +439,5 @@
-    def runtimeClass = upperBound.runtimeClass
-    override def toString =
-      "_" +
-        (if (lowerBound eq Nothing) "" else " >: "+lowerBound) +
-        (if (upperBound eq Nothing) "" else " <: "+upperBound)
+	def runtimeClass = upperBound.runtimeClass
+	override def toString =
+	  "_" +
+		(if (lowerBound eq Nothing) "" else " >: "+lowerBound) +
+		(if (upperBound eq Nothing) "" else " <: "+upperBound)
@@ -446,1 +447,1 @@
-    */
+   */
@@ -448,1 +449,1 @@
-    new WildcardManifest[T](lowerBound, upperBound)
+	new WildcardManifest[T](lowerBound, upperBound)
@@ -452,4 +453,4 @@
-    // We use an `Array` instead of a `Seq` for `parents` to avoid cyclic dependencies during deserialization
-    // which can cause serialization proxies to leak and cause a ClassCastException.
-    def runtimeClass = parents(0).runtimeClass
-    override def toString = parents.mkString(" with ")
+	// We use an `Array` instead of a `Seq` for `parents` to avoid cyclic dependencies during deserialization
+	// which can cause serialization proxies to leak and cause a ClassCastException.
+	def runtimeClass = parents(0).runtimeClass
+	override def toString = parents.mkString(" with ")
@@ -460,1 +461,1 @@
-    new IntersectionTypeManifest[T](parents.toArray)
+	new IntersectionTypeManifest[T](parents.toArray)
